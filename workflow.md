## Основные приемы работы с GIT

### I. Workflow локальной работы с GIT (без использования сервера GitLab)  

Запускаем командный проуессор (cmd.exe) и переходим в катлог с нашим проектом.  

    cd c:\myproject
  
Создаем (инициализируем) репозиторий Git в каталоге с нашим проектом. После выполнения указанной ниже команды в каталоге проекта создастся репозиторий в виде скрытой папки ".git" в которой будут сохранятся все данные системы Git.

    git init


Для того, чтобы Git отслеживал появление новых файлов в проекти и их изменение необходимо индексировать их. Команда git add используется для индексации как отдельных файлов так и каталогов. Индексировать измененные файлы необходимо каждый раз, когда необходимо чтобы изменния попали в репозитоий Git. Самое простое это индексировать сразу весь каталог нашего проекта следующим образом:

    git add .

Далее необходимо зафиксировать изменения и в репозитории Git появится первая точка истории изменений соответсвующая текущему состоянию нашего проекта под названем "initial commit".

    git commit -m "Initail commit"

Изначально все коммиты сохраняются в основную ветвь проекта, которая назыывается "master" (все существующие ветви можно посмотреть командой git branch). Если нам необходимо разработать какой-то новый функционал в проекте, создадим новую ветвь и дадим ей к примеру имя "new-fwature":

    git branch new-feature

Затем переключимся в эту ветвь чтобы вести разработку именно в ней (При этом основная ветвь "master" останется неизменной:

    git checkout new-feature

Два предыдущих шага (создание новой ветки и переключение на нее можно выполнить одной командой):

    git checkout -b new-feature

Далее ведем разработку нового функционала, работаем с кодом нашей программы. После того как понимаем, что нужно зафиксировать промежуточный итог работы (закончился рабочий день или достигнута некая промежуточная цель разработки нового функционала) необходимо вновь проиндексировть внесенные нами изменения и выполнить коммит:

    git add .
    git commit -m "Done with the new feature"

Таким образом изменяя код, индексируя изменния и делая коммиты мы создаем точки истории в репозитории Git (получая возможность отката изменений по выполненным коммитам). Посмотреть историю изменений для нашей ветки можно командой:

    git log

Далее, завершив работу над новым функционалом, и протестировав его, нам необходимо "Слить" все наши изменения в основную ветку "master". чтобы выполнить это сначала переключаемся на ветку "master" командой:

    git checkout master

Затем, при желании можно сравнить две наших ветки и просмотреть все изменения, которые мы внесли в проект, разрабатывая новый функционал работая в ветке "new-feature":

    git diff HEAD new-feature

Приведенная выше команда, сравнивает и выводит различия между последним состоняием (HEAD) текущей ветки (а мы находимся в ветке "master") и веткой new-feature. Конечно можно и не смотреть эти различия, если мы хорошо помним что мы делали в ветке "new-feature", а просто сразу произвести слияние ветки "new-feature" с ткущей веткой (в нашем случае "master"):

    git merge new-feature

Дальше, если слияние произошло без проблем, то скорее всего ветка new-feature Нам больше не нужна и ее можно удалить:

    git branch -d new_feature

Ну и на всякий случай, оценим свою работу и посмотрим сделанные нами коммиты в течение последнего дня:

    git log --since="1 day"


### II. Отправка проекта GIT на сервер GitLab.
Поскольку у нас теперь есть сервер для хранения и совместной работы с репозиториями GIT, то как минимум по окончании рабочего дня необходимо отправить наш проект на этот сервер. При создании нового проекта на сервере, GitLab даст подсказку как это сделать. Например, создадим на серверер GitLab публичный проект с именем "my-super-project" (используя вход на сервер GitLab пользователем "mitshel"). Тогда, для уже существующего локального репозитория Git сначала необходимо создать указатель на удаленный сервер (обычно его называют "origin"). Сделать это можно следующией командой:

    git remote add origin git@gitlab.dsnet.ru:mitshel/my-super-project.git

Затем отправим наш проект на сервер GitLab при помощи команды:

    git push -u origin master

Указаная выше команда отправляет ("push") на сервер, который мы ранее назвали "origin" ветку локального репозитория "master". Опция -u заставляет Git запомнить указанный сервер и ветку как значения "по умолчанию", так, что впоследствии для отправки новых изменений по нашему проекту достаточно будет вводить команду:

    git push


### III. Workflow групповой работы с GIT (с использованием GitLab)
Предположим теперь, что вы и несколько ваших коллег создали общий открытый репозиторий, чтобы заняться неким общим проектом. Ниже приведена наиболее распространненая модель совместной работы с Git.   
Если вы создатель проекта то, вероятно вы уже воспользовались частью I и II настоящей статьи, чтобы создать репозиторий Git и отправить его на сервер GitLab.
Если же вы присодинятесь проекту для совместной работы, то первоначально вам необходимо получить клон проекта к себе на компьютер. Это можно слделать следующей командой:  

    git clone git@gitlab.dsnet.ru:mitshel/my-super-project.git

Даляее, перед тем, как что менять в коде получаем последние изменения проекта:

    git pull

Смотрим, что-же изменилось:

    git diff HEAD^

Создаем новую ветвь и переключаемся в нее:

    git checkout -b super-feature

Работаем какое-то время, затем индексируем все изменения и одновременно делаем коммит одной командой:

    git commit -a -m "Created the new super-feature"

Переключаемся в главную ветвь:

    git checkout master

Поскольку вероятно, что пока мы вели разработку в ветви super-feature, кто-то из наших коллег, мог внести правки в главную ветвь, то сначала перед слиянием нашей super-feature обновляем ветвь master:

    git pull

Проводим слияние с веткой super-feature:

    git merge super-feature

Делаем коммит для произведнного слияния (возможно перед этим предется разрешать конфликты слияния):

    git commit -a

После совершения коммита просматриваем изменения:

    git diff HEAD^

Дальше систуация может развиваться и так - проведя проверки, тесты после проведенного слияния мы вдруг обнаруживаем, что после слияния наш проект стал практически неработоспособен. 
Наши коллекги будут в ужасе, если мы зальем ветку master в которую мы слили super-feature. Таким образом, выходом будет "жесткий" сброс произведенного слияния и возврат ветки master в исходное состояние:

    git reset --hard ORIG_HEAD

Далее, переключаемся в неудачную ветку super-feature для внесения необходимых правок:

    git checkout super-feature

Делаем правки. После чего можно переименовать ветвь (не обязательно, просто в качестве примера):

    git -m super-feature super-feature-v2

Совершаем коммит:

    git commit -a -m "Tested super-feature"

Опять переходим в главную ветку и не забываем обновить ее:

    git checkout master
    git pull

Снова делаем слияние:

    git merge super-feature-v2

Проверяем работу, понимаем, что все хорошо и далее делаем коммит и отправляем мастер-ветку на сервер:

    git commit -a
    git push

Теперь можно удалить ветку в которой мы вели разработку:

    git branch -d super-feature-v2


### IV. Другие полезные приемы работы с удаленным сервером GIT.

Если нам нужно отправить не основную, а какую нибудь другую ветку на сервер, то это можно сделать так:

    git push origin feature

А если мы хотим отправить на сервер из локального репозитория ветку "feature", хотим чтобы на сервере эта ветка называлась, к примеру, "new-feature", то сделать это можно следующей командой:

    git push origin feature:new-feature

Если же нам необходимо удалить с сервера созданную ранее ветку "new-feature", это делается следующей командой:

    git push origin :new-feature


